import { ChatModel } from "../../../DB/models/chaatmodel.js";
// import { scketConnections } from "../../../DB/models/User.model.js";
import { authenticationSocket } from "../../../middlewere/auth.socket.middlewere.js";
import * as dbservice from "../../../DB/dbservice.js"
import { scketConnections } from "../../../DB/models/User.model.js";
import mongoose from 'mongoose';








// export const sendMessage = (socket) => {
//     socket.on("sendMessage", async (messageData) => {
//         try {
//             const { data } = await authenticationSocket({ socket });

//             if (!data.valid) {
//                 return socket.emit("socketErrorResponse", data);
//             }

//             const user = data.user;
//             const userId = user._id.toString();
//             const {
//                 message,
//                 voiceUrl,
//                 imageUrl,
//                 fileUrl,
//                 fileName,
//                 fileSize,
//                 type
//             } = messageData;

//             const nothingSent = [message, voiceUrl, imageUrl, fileUrl]
//                 .every(val => !val || (typeof val === "string" && val.trim() === ""));

//             if (nothingSent) {
//                 return socket.emit("socketErrorResponse", {
//                     message: "âŒ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© ÙØ§Ø±ØºØ©.",
//                     status: 400
//                 });
//             }

//             let chat = await ChatModel.findOne();
//             if (!chat) {
//                 chat = await ChatModel.create({
//                     participants: [user._id],
//                     messages: []
//                 });
//             }

//             if (!chat.participants.includes(user._id)) {
//                 chat.participants.push(user._id);
//             }

//             const messageId = new mongoose.Types.ObjectId();
//             const messageDoc = {
//                 _id: messageId,
//                 message: message || null,
//                 voiceUrl: voiceUrl || null,
//                 imageUrl: imageUrl || null,
//                 fileUrl: fileUrl || null,
//                 fileName: fileName || null,       // âœ… Ø§Ø³Ù… Ø§Ù„Ù…Ù„Ù
//                 fileSize: fileSize || null,       // âœ… Ø§Ù„Ø­Ø¬Ù…
//                 type: type || 'text',             // âœ… Ø§Ù„Ù†ÙˆØ¹
//                 senderId: user._id
//             };

//             chat.messages.push(messageDoc);
//             await chat.save();

//             const messageToSend = {
//                 _id: messageId,
//                 message: messageDoc.message,
//                 voiceUrl: messageDoc.voiceUrl,
//                 imageUrl: messageDoc.imageUrl,
//                 fileUrl: messageDoc.fileUrl,
//                 fileName: messageDoc.fileName,
//                 fileSize: messageDoc.fileSize,
//                 type: messageDoc.type,
//                 senderId: {
//                     _id: user._id,
//                     username: user.username
//                 }
//             };

//             for (const participantId of chat.participants) {
//                 const idStr = participantId.toString();
//                 if (idStr !== userId && scketConnections.has(idStr)) {
//                     socket.to(scketConnections.get(idStr)).emit("receiveMessage", messageToSend);
//                 }
//             }

//             socket.emit("successMessage", { message: messageToSend });

//         } catch (error) {
//             console.error("âŒ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø©:", error);
//             socket.emit("socketErrorResponse", {
//                 message: "âŒ ÙØ´Ù„ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø©",
//                 status: 500
//             });
//         }
//     });
// };











export const sendMessage = (socket) => {
    socket.on("sendMessage", async (messageData) => {
        try {
            const { data } = await authenticationSocket({ socket });

            if (!data.valid) {
                return socket.emit("socketErrorResponse", data);
            }

            const user = data.user;
            const userId = user._id.toString();
            const {
                message,
                voiceUrl,
                imageUrl,
                fileUrl
            } = messageData;

            // Ù„Ø§Ø²Ù… Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„ Ø­Ø§Ø¬Ø© ÙˆØ§Ø­Ø¯Ø©
            const nothingSent = [message, voiceUrl, imageUrl, fileUrl]
                .every(val => !val || (typeof val === "string" && val.trim() === ""));

            if (nothingSent) {
                return socket.emit("socketErrorResponse", {
                    message: "âŒ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© ÙØ§Ø±ØºØ©.",
                    status: 400
                });
            }

            // Ø¬Ù„Ø¨ Ø£Ùˆ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø´Ø§Øª
            let chat = await ChatModel.findOne();
            if (!chat) {
                chat = await ChatModel.create({
                    participants: [user._id],
                    messages: []
                });
            }

            // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù„Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ†
            if (!chat.participants.includes(user._id)) {
                chat.participants.push(user._id);
            }

            const messageId = new mongoose.Types.ObjectId();
            const messageDoc = {
                _id: messageId,
                message: message || null,
                voiceUrl: voiceUrl || null,
                imageUrl: imageUrl || null,
                fileUrl: fileUrl || null,
                senderId: user._id
            };

            chat.messages.push(messageDoc);
            await chat.save();

            const messageToSend = {
                _id: messageId,
                message: messageDoc.message,
                voiceUrl: messageDoc.voiceUrl,
                imageUrl: messageDoc.imageUrl,
                fileUrl: messageDoc.fileUrl,
                senderId: {
                    _id: user._id,
                    username: user.username
                }
            };

            for (const participantId of chat.participants) {
                const idStr = participantId.toString();
                if (idStr !== userId && scketConnections.has(idStr)) {
                    socket.to(scketConnections.get(idStr)).emit("receiveMessage", messageToSend);
                }
            }

            socket.emit("successMessage", { message: messageToSend });

        } catch (error) {
            console.error("âŒ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø©:", error);
            socket.emit("socketErrorResponse", {
                message: "âŒ ÙØ´Ù„ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø©",
                status: 500
            });
        }
    });
};
  

const waitingUsers = [];

export const handleMatching = (socket) => {
    socket.on("startMatching", async ({ gender, lookingFor }) => {
        const { data } = await authenticationSocket({ socket });

        if (!data.valid) {
            return socket.emit("socketErrorResponse", data);
        }

        const user = data.user;
        const userId = user._id.toString();
        const classId = user.classId?.toString();

        console.log("ðŸ“¥ ØªÙ… Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ startMatching:", {
            userId, gender, lookingFor, classId
        });

        if (!classId) {
            return socket.emit("socketErrorResponse", {
                message: "âŒ Ù„Ø§ ÙŠÙˆØ¬Ø¯ ØµÙ Ø¯Ø±Ø§Ø³ÙŠ Ù…Ø±ØªØ¨Ø· Ø¨Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…",
                status: 400
            });
        }

        // Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ù‚Ø¨Ù„ Ø£ÙŠ Ø´ÙŠØ¡
        console.log("ðŸ“ƒ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„Ø­Ø§Ù„ÙŠØ©:", waitingUsers);

        const alreadyWaiting = waitingUsers.some(
            (u) => u.userId === userId && u.classId === classId
        );
        if (alreadyWaiting) {
            console.log("â›” Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„ÙØ¹Ù„ ÙÙŠ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±");
            return;
        }

        const matchIndex = waitingUsers.findIndex(
            (u) =>
                u.classId === classId &&
                u.gender === lookingFor &&
                u.lookingFor === gender
        );

        if (matchIndex !== -1) {
            const matchedUser = waitingUsers.splice(matchIndex, 1)[0];

            const roomId = `room-${userId}-${matchedUser.userId}`;

            console.log("âœ… ØªÙ…Øª Ø§Ù„Ù…Ø·Ø§Ø¨Ù‚Ø©:", { user1: userId, user2: matchedUser.userId });

            socket.emit("matched", { roomId, partnerId: matchedUser.userId });

            if (scketConnections.has(matchedUser.userId)) {
                socket
                    .to(scketConnections.get(matchedUser.userId))
                    .emit("matched", { roomId, partnerId: userId });
            }

        } else {
            const timeout = setTimeout(() => {
                const index = waitingUsers.findIndex((u) => u.userId === userId);
                if (index !== -1) {
                    waitingUsers.splice(index, 1);
                    socket.emit("timeout", {
                        message: "â³ Ø§Ù†ØªÙ‡Ù‰ ÙˆÙ‚Øª Ø§Ù„Ø¨Ø­Ø«ØŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø´Ø±ÙŠÙƒ.",
                    });
                }
            }, 2 * 60 * 1000);

            waitingUsers.push({
                userId,
                classId,
                gender,
                lookingFor,
                socketId: socket.id,
                timeout
            });

            console.log("âž• ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±");

            socket.emit("waiting", {
                message: "â³ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø´Ø±ÙŠÙƒ Ù…Ø·Ø§Ø¨Ù‚ ÙÙŠ Ù†ÙØ³ Ø§Ù„ØµÙ Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠ...",
            });
        }
    });

    socket.on("disconnect", () => {
        const index = waitingUsers.findIndex((u) => u.socketId === socket.id);
        if (index !== -1) {
            clearTimeout(waitingUsers[index].timeout);
            waitingUsers.splice(index, 1);
        }
    });
};






export const handleVoiceCall = (socket) => {
    socket.on("call-user", ({ toUserId, offer }) => {
        const toSocketId = scketConnections.get(toUserId);
        if (!toSocketId) return;
        console.log("ðŸ“ž Ø¥Ø±Ø³Ø§Ù„ offer Ù…Ù†", socket.user._id, "Ø¥Ù„Ù‰", toUserId);
        socket.to(toSocketId).emit("receive-call", {
            fromUserId: socket.user._id,
            offer,
        });
    });

    socket.on("answer-call", ({ toUserId, answer }) => {
        const toSocketId = scketConnections.get(toUserId);
        if (!toSocketId) return;
        console.log("âœ… Ø§Ù„Ø±Ø¯ Ù…Ù†", socket.user._id, "Ø¥Ù„Ù‰", toUserId);
        socket.to(toSocketId).emit("call-answered", {
            fromUserId: socket.user._id,
            answer,
        });
    });

    socket.on("ice-candidate", ({ toUserId, candidate }) => {
        const toSocketId = scketConnections.get(toUserId);
        if (!toSocketId) return;
        console.log("ðŸ§Š ICE Ù…Ù†", socket.user._id, "Ø¥Ù„Ù‰", toUserId);
        socket.to(toSocketId).emit("ice-candidate", {
            fromUserId: socket.user._id,
            candidate,
        });
    });
};



  
